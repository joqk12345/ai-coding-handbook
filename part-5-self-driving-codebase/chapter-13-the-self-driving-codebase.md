# 第13章：自主代码库 —— 背景智能体与软件交付的下一个时代

> *从"人操作机器"到"机器自主运行"——软件工程的根本范式转变。*

## 背景智能体的崛起

### 当前状态：人机协作的黄金分割

在现代软件交付中，背景智能体正在承担越来越多的工作：

```
传统开发模式          现代智能体辅助模式        未来自主模式
├─ 人类注意力: 100%   ├─ 人类注意力: 25%       ├─ 人类注意力: 5%
└─ 机器工作: 0%       └─ 智能体活动: 75%       └─ 自主运行: 95%
```

这不是遥不可远的未来——Stripe、Ramp 等公司已经在生产环境中运行这样的系统。他们发布的 Minions 平台等解决方案，标志着软件交付的"自动驾驶时代"已经到来。

### 为什么 localhost 成为瓶颈

我们的开发系统是基于"人类在键盘前"这一约束设计的。但现在：

| 演进阶段 | 问题 | 症状 |
|---------|------|------|
| **自动补全 → 编码智能体** | 单个智能体在笔记本上运行 | 尚可管理 |
| **编码智能体 → 并行智能体** | 3个智能体同时运行 | 开始争夺资源 |
| **并行智能体 → 后台智能体** | 需要7×24小时运行 | localhost 无法满足 |

**localhost 的根本限制：**
- **状态竞争**：多个智能体争夺机器状态
- **安全风险**：机密信息暴露于本地环境
- **可用性限制**：机器休眠时一切停止

对于独立开发者这可能勉强可用，但对于专业工程团队，这根本不可持续。我们必须将工程师从工作站解耦。智能体需要在后台、安全地、规模化地运行。

## 虚假顶峰：个人速度 ≠ 组织速度

### 你是否登上了虚假顶峰？

你推出了编码智能体。工程师们更快了。PR 如潮水般涌入。

但周期时间没有变化。DORA 指标持平。待办事项却在增长。

**因为收益是在个人层面复合的，而不是组织层面。**

你投资编码智能体的时间越长，而不解决周围的系统，你就越深地陷入这个陷阱。

```
开发机器上的智能体
    ↓
虚假顶峰：个人速度提升，但组织速度停滞
    ↓
第一步：建立后台智能体原语
第二步：找到系统的瓶颈
第三步：扩展你的软件工厂
```

## 通往自主代码库的三步路径

### 第一步：建立后台智能体原语

自主智能体需要在你的笔记本上不存在的底层架构。以下构建块将演示与部署区分开来——沙盒执行、治理、内部系统连接、触发自动化和集群协调。每一个都解锁下一个。

#### 1. 开发环境

**智能体需要一台计算机**

后台运行的智能体需要自己的执行环境，配备完整的工具链、运行测试的能力以及通过 secrets 访问系统的权限。

环境应该是隔离的、可重现的，并与生产系统保持高度一致性，以支持智能体集群。其他一切都建立在此之上。

| 模式 | 描述 | 适用场景 |
|------|------|----------|
| **智能体拥有开发环境** | VM 运行包含代码库、测试套件、数据库和内部网络访问的开发容器。最接近人类开发者的工作方式。Stripe、Ramp 等公司选择此模式。 | 企业级工程工作流 |
| **沙盒作为工具** | 智能体在服务器或本地运行。需要执行代码时，通过 API 调用单独的远程沙盒。保持 secrets 和执行一定程度隔离，但智能体只能执行代码而不能完整开发。 | 构建智能体产品而非改进内部工程工作流 |

**相关阅读**: [Don't Build Your Own Sandbox](https://www.google.com/search?q=Don%27t+Build+Your+Own+Sandbox+Lou+Bichard+Ona) by Lou Bichard, Field CTO at Ona

#### 2. 治理

**在运行时强制执行，而非通过提示**

智能体是你系统中的参与者。它们需要与人类贡献者相同的控制——身份、权限、审计追踪。

区别：通过系统提示强制执行的治理（"请不要删除文件"）是建议。在执行层强制执行的治理——拒绝列表、有范围的凭证、确定性命令阻止——才是真正的治理。没有它，安全团队会完全否决自主智能体。而且他们是对的。

#### 3. 上下文与连接

**在你的防火墙后面**

无法访问内部系统的沙盒是玩具。智能体需要承担 IAM 角色、查询数据库副本、访问内部 API 以及从私有注册表拉取——所有这些都在你的网络内部。上下文和连接将隔离的执行转化为真正的工作。

#### 4. 触发器

**将人类从调用循环中移除**

如果每个智能体运行都以开发者输入提示开始，你还没有自动化工作流——只是自动化了工作。触发器将智能体连接到重要的事件：计划、webhook、系统信号。每个模式映射到不同的范围和节奏。

| 触发模式 | 描述 | 特点 |
|----------|------|------|
| ⏱ **计划智能体** | 定时触发。可预测、有界、高容量——依赖更新、lint 扫描、覆盖率执行。 | 基于时间、可预测、大批量 |
| ⚡ **事件驱动智能体** | 由系统事件触发——PR 打开、CVE 发布、警报触发。响应式、并发、始终监听。 | 事件响应、并发、实时 |
| ⊞ **智能体集群** | 一个任务跨多个仓库。每个智能体独立工作并产生自己的贡献。 | 横向扩展、并行、分布式 |
| ◉ **智能体集群** | 多个智能体，一个结果。每个智能体在不同方面工作，结果汇聚成单一可交付物。 | 协作、分布式、聚合 |
| 📱 **移动端** | 直接从手机或 iMessage 触发一个或多个智能体。一条消息，一个集群展开。新的 TDD，出租车驱动开发。 | 移动优先、消息驱动、即时 |

#### 5. 集群协调

**一个意图，每个仓库**

更新一个仓库是编码智能体任务。更新 500 个是集群任务。相同的沙盒，复制到需要更改的每个仓库——并行配置、进度跟踪、聚合结果。这就是个人生产力变成组织吞吐量。

---

### 第二步：找到你系统的瓶颈

原语给你能力。你在哪里应用它们才是重要的。这意味着要做这项工作：调查你的开发者、与团队坐在一起、映射时间都去哪里了。每个组织的瓶颈都不同。值得首先解决的那些并不总是显而易见的。

#### 代码审查堆积如山

PR 在上下文切换时坐上几个小时。在规模上，审查队列积压，交货时间保持持平尽管编码更快。在任何人看到之前，后台智能体审查每个 PR，因此审查者专注于设计而非格式。

---

### 第三步：扩展你的软件工厂

工程组织是一个工业系统。今天，开发者站在每个站点：编写、审查、测试。后台智能体改变了运营模式。工厂运行，但你的工程师在循环上移动而不是在其中。

| 阶段 | 传统模式 | 自主模式 |
|------|----------|----------|
| **PLAN** | 人工规划 | 智能体辅助规划 |
| **CODE** | 人工编码 | 智能体辅助编码 |
| **REVIEW** | 人工审查 | 智能体预审查 |
| **TEST** | 人工测试 | 智能体测试 |
| **DEPLOY** | 人工部署 | 智能体辅助部署 |

**每个 PR 在任何人看到之前都由智能体审查**

CI 失败在开发者被呼叫之前由智能体调查和修复

开发者从不手动解决智能体 PR 上的合并冲突

智能体对每个生产事件进行首次调查

安全漏洞在数小时内修补，而非数周

**阅读**: [Industrializing Software Development](https://www.google.com/search?q=Industrializing+Software+Development+Christian+Weichel+Ona) by Christian Weichel, co-founder of Ona

---

## 结语：软件工程的未来

自主代码库不是取代工程师，而是让工程师专注于真正重要的事情：创造性问题解决、架构设计、用户体验。

后台智能体将接管重复性工作、日常维护和规模化任务。这不是一个遥远的未来——Stripe、Ramp 等公司已经在生产环境中运行这些系统。

**关键洞察**：

1. **个人速度 ≠ 组织速度** — 投资于编码智能体而不解决周围系统，只会加深虚假顶峰
2. **localhost 成为瓶颈** — 专业工程需要后台、安全、规模化的智能体执行
3. **三步路径**：建立原语 → 找到瓶颈 → 扩展工厂

软件工程正在从"人类操作机器"转变为"机器自主运行"。自主代码库是这个旅程的下一站。